\section{Limitation}
\label{sec:discussion}
\NP{} bases on compiler-based instrumentation to capture memory accesses. Therefore, it shares the same shortcomings and strengths of all compiler-based instrumentation. On the one side, \NP{} can perform static analysis to reduce unnecessary memory accesses, such as accesses to stack variables. With static analysis, \NP{} typically achieves much better performance than binary-based instrumentation tools, such as NUMAPROF~\cite{valat:2018:numaprof}. On the other side, \NP{} requires the re-compilation (and the availability of the source code), and will miss memory accesses without the instrumentation. That is, it cannot detect NUMA issues caused by non-instrumented components (e.g., libraries), suffering from false negatives. 
In the future, we are planning to add binary-based instrumentation to \NP{} so that it could be utilized without the requirement of source code, and detect more potential issues caused by libraries (therefore reduce false negatives). 
%However, most issues should only occur in applications, but not libraries. 
%\todo{Mention that it is beneficial to combine two approaches together, which will be our future plan}. 

%\XZ{In our extensive evaluation, we did compiler-based instrumentation for most applications by only recompiling their source code without other dependent libraries. This could reduce lots of overheads caused by unnecessary instrumentation for memory accesses from third-party libraries. However as we can see from the evaluation section that it is effective to detect major issues and gets excellent improvements. But in few cases like dedup and UMT2013, this approach  could missed some useful information. One situation is that the compiler-based approach only supports some popular programming languages like C, C++ and etc, which depends on what compiler is used. So if certain languages used in the application that is not supported by the compiler, it could limit the use of this tool. For example, Fortran is used in the UMT2013 and LLVM does not support the transformation of Fortran codes, so that \NP{} can not do instrumentation of that part of code and no way to collect any useful information for that. And in some few cases, third-party libraries did lots of remote memory accesses, which will be ignored too. For instance in the dedup, it uses some local static libraries and there are lots of remote memory access happened inside that. If \NP{} did not compile the libraries, \NP{} can not report accurate information for its thread-imbalance issue.}